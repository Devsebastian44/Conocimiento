# Llamada de Funciones

En Elixir, las funciones se definen dentro de módulos y se pueden llamar de varias maneras.

```elixir
defmodule Calculator do
  # Función pública
  def add(a, b) do
    a + b
  end
  
  # Función pública con sintaxis de una línea
  def subtract(a, b), do: a - b
  
  # Función con múltiples cláusulas
  def divide(a, 0), do: {:error, "Division by zero"}
  def divide(a, b), do: {:ok, a / b}
  
  # Función privada
  defp multiply_by_two(x), do: x * 2
  
  def double(x) do
    multiply_by_two(x)  # Llamada a función privada
  end
end

# Llamadas a funciones
Calculator.add(5, 3)           # 8
Calculator.subtract(10, 4)     # 6
Calculator.divide(10, 2)       # {:ok, 5.0}
Calculator.divide(10, 0)       # {:error, "Division by zero"}
Calculator.double(7)           # 14

# Llamada con alias
alias Calculator, as: Calc
Calc.add(2, 3)                 # 5

# Importar funciones
import Calculator
add(1, 2)                      # 3 (sin prefijo del módulo)
```

## Llamadas con pipe operator:

```elixir
# Sin pipe
result = Calculator.add(Calculator.multiply(5, 3), 2)

# Con pipe
result = 5
|> Calculator.multiply(3)
|> Calculator.add(2)

# Ejemplo más complejo
"hello world"
|> String.split()
|> Enum.map(&String.capitalize/1)
|> Enum.join(" ")
# "Hello World"
```

# Guard Clauses

Las guard clauses permiten añadir condiciones adicionales a las funciones.

## Guards básicos:

```elixir
defmodule NumberChecker do
  def check(x) when is_integer(x) and x > 0 do
    "Positive integer: #{x}"
  end
  
  def check(x) when is_integer(x) and x < 0 do
    "Negative integer: #{x}"
  end
  
  def check(0) do
    "Zero"
  end
  
  def check(x) when is_float(x) do
    "Float: #{x}"
  end
  
  def check(_) do
    "Unknown type"
  end
end

NumberChecker.check(5)      # "Positive integer: 5"
NumberChecker.check(-3)     # "Negative integer: -3"
NumberChecker.check(0)      # "Zero"
NumberChecker.check(3.14)   # "Float: 3.14"
NumberChecker.check("hi")   # "Unknown type"
```

## Guards con pattern matching:

```elixir
defmodule ListProcessor do
  def process([]), do: "Empty list"
  
  def process([head]) when is_atom(head) do
    "Single atom: #{head}"
  end
  
  def process([head]) when is_number(head) do
    "Single number: #{head}"
  end
  
  def process([head | tail]) when length(tail) < 3 do
    "Short list starting with #{head}"
  end
  
  def process([head | tail]) when length(tail) >= 3 do
    "Long list starting with #{head}"
  end
end

ListProcessor.process([])              # "Empty list"
ListProcessor.process([:hello])        # "Single atom: hello"
ListProcessor.process([42])            # "Single number: 42"
ListProcessor.process([1, 2])          # "Short list starting with 1"
ListProcessor.process([1, 2, 3, 4, 5]) # "Long list starting with 1"
```

## Guards con expresiones complejas:

```elixir
defmodule AdvancedGuards do
  def classify_age(age) when age >= 0 and age < 18 do
    "Minor"
  end
  
  def classify_age(age) when age >= 18 and age < 65 do
    "Adult"
  end
  
  def classify_age(age) when age >= 65 do
    "Senior"
  end
  
  def valid_email?(email) when is_binary(email) do
    String.contains?(email, "@") and String.contains?(email, ".")
  end
  
  def calculate_discount(price, customer_type) 
      when is_number(price) and price > 0 and customer_type in [:vip, :regular] do
    case customer_type do
      :vip -> price * 0.8      # 20% descuento
      :regular -> price * 0.95 # 5% descuento
    end
  end
end
```

# Limitaciones en Guard Clauses

Los guards tienen limitaciones específicas en cuanto a qué expresiones pueden usar.

## Expresiones permitidas en guards:

```elixir
defmodule GuardExamples do
  # Comparaciones
  def compare(x) when x > 10, do: "greater than 10"
  def compare(x) when x == 5, do: "equals 5"
  def compare(x) when x != 0, do: "not zero"
  
  # Operadores lógicos
  def logical(x) when x > 0 and x < 100, do: "between 0 and 100"
  def logical(x) when x < 0 or x > 1000, do: "outside normal range"
  def logical(x) when not is_nil(x), do: "not nil"
  
  # Funciones type-checking
  def type_check(x) when is_atom(x), do: "atom"
  def type_check(x) when is_binary(x), do: "binary"
  def type_check(x) when is_list(x), do: "list"
  def type_check(x) when is_map(x), do: "map"
  def type_check(x) when is_tuple(x), do: "tuple"
  
  # Funciones matemáticas básicas
  def math_ops(x) when abs(x) > 10, do: "absolute value > 10"
  def math_ops(x) when rem(x, 2) == 0, do: "even number"
  def math_ops(x) when trunc(x) == x, do: "whole number"
  
  # Funciones de longitud
  def length_check(list) when length(list) > 3, do: "long list"
  def size_check(tuple) when tuple_size(tuple) == 2, do: "pair"
  def map_check(map) when map_size(map) > 0, do: "non-empty map"
end
```

## Expresiones NO permitidas en guards:

```elixir
defmodule InvalidGuards do
  # ❌ No se pueden usar funciones personalizadas
  # def custom_check(x) when my_custom_function(x), do: "valid"
  
  # ❌ No se pueden usar funciones que pueden fallar
  # def file_check(path) when File.exists?(path), do: "file exists"
  
  # ❌ No se pueden usar calls a funciones de otros módulos (excepto permitidas)
  # def string_check(s) when String.contains?(s, "test"), do: "contains test"
  
  # ❌ No se pueden usar variables definidas fuera
  # limit = 100
  # def check_limit(x) when x < limit, do: "within limit"
  
  # ✅ Alternativas válidas:
  def file_exists_check(path) do
    if File.exists?(path) do
      "file exists"
    else
      "file not found"
    end
  end
  
  def string_contains_check(s) do
    if String.contains?(s, "test") do
      "contains test"
    else
      "doesn't contain test"
    end
  end
end
```


# Guard vs Lógica Condicional

Comparación entre usar guards y lógica condicional dentro de las funciones.

```elixir
defmodule GuardVsConditional do
  # ✅ Usando guards (preferido cuando es posible)
  def process_number(x) when is_integer(x) and x > 0 do
    "Positive integer: #{x}"
  end
  
  def process_number(x) when is_integer(x) and x < 0 do
    "Negative integer: #{x}"
  end
  
  def process_number(x) when is_float(x) do
    "Float: #{x}"
  end
  
  def process_number(_) do
    "Invalid input"
  end
  
  # ❌ Usando lógica condicional (menos elegante)
  def process_number_conditional(x) do
    cond do
      is_integer(x) and x > 0 -> "Positive integer: #{x}"
      is_integer(x) and x < 0 -> "Negative integer: #{x}"
      is_float(x) -> "Float: #{x}"
      true -> "Invalid input"
    end
  end
  
  # ✅ Guards para validación temprana
  def calculate_area(length, width) when length > 0 and width > 0 do
    length * width
  end
  
  def calculate_area(_, _) do
    {:error, "Dimensions must be positive"}
  end
  
  # ❌ Validación dentro de la función
  def calculate_area_conditional(length, width) do
    if length > 0 and width > 0 do
      length * width
    else
      {:error, "Dimensions must be positive"}
    end
  end
end
```

## Cuándo usar guards vs condicionales:

```elixir
defmodule BestPractices do
  # ✅ Usar guards para: tipo de datos, valores simples, pattern matching
  def handle_response({:ok, data}) when is_binary(data), do: String.upcase(data)
  def handle_response({:error, reason}), do: "Error: #{reason}"
  
  # ✅ Usar condicionales para: lógica compleja, llamadas a funciones
  def process_user(user) do
    if user.active and user.verified and not user.banned do
      perform_user_action(user)
    else
      {:error, "User not eligible"}
    end
  end
  
  # ✅ Combinar ambos apropiadamente
  def authenticate(token) when is_binary(token) do
    case verify_token(token) do
      {:ok, user} -> 
        if user.active do
          {:ok, user}
        else
          {:error, "User inactive"}
        end
      error -> error
    end
  end
  
  def authenticate(_), do: {:error, "Invalid token format"}
end
```


# Parámetros por Default

Elixir permite definir valores por defecto para los parámetros de las funciones.

```elixir
defmodule DefaultParams do
  # Parámetros por defecto básicos
  def greet(name, greeting \\ "Hello") do
    "#{greeting}, #{name}!"
  end
  
  # Múltiples parámetros por defecto
  def create_user(name, age \\ 25, role \\ :user, active \\ true) do
    %{name: name, age: age, role: role, active: active}
  end
  
  # Parámetros por defecto con expresiones
  def log_message(message, timestamp \\ DateTime.utc_now(), level \\ :info) do
    "#{timestamp} [#{level}]: #{message}"
  end
  
  # Parámetros por defecto con funciones
  def generate_id(prefix \\ "user", suffix \\ fn -> :rand.uniform(1000) end) do
    "#{prefix}_#{suffix.()}"
  end
end

# Uso de funciones con parámetros por defecto
DefaultParams.greet("Ana")                           # "Hello, Ana!"
DefaultParams.greet("Ana", "Hi")                     # "Hi, Ana!"

DefaultParams.create_user("Juan")                    # %{name: "Juan", age: 25, role: :user, active: true}
DefaultParams.create_user("Juan", 30)                # %{name: "Juan", age: 30, role: :user, active: true}
DefaultParams.create_user("Juan", 30, :admin)        # %{name: "Juan", age: 30, role: :admin, active: true}
DefaultParams.create_user("Juan", 30, :admin, false) # %{name: "Juan", age: 30, role: :admin, active: false}
```

## Consideraciones importantes:

```elixir
defmodule DefaultConsiderations do
  # ✅ Los defaults deben ir al final
  def good_function(required, optional \\ "default") do
    "#{required} - #{optional}"
  end
  
  # ❌ Esto no compila - defaults no pueden ir antes de parámetros requeridos
  # def bad_function(optional \\ "default", required) do
  #   "#{required} - #{optional}"
  # end
  
  # ✅ Múltiples funciones con diferentes aridades
  def process_data(data), do: process_data(data, %{})
  def process_data(data, options) when is_map(options) do
    # procesamiento con opciones
    {data, options}
  end
  
  # ✅ Defaults que dependen de otros parámetros
  def create_filename(name, extension \\ nil) do
    ext = extension || Path.extname(name)
    if ext == "" do
      "#{name}.txt"
    else
      "#{name}#{ext}"
    end
  end
end
```


# Funciones Privadas

Las funciones privadas solo pueden ser llamadas desde dentro del mismo módulo.

```elixir
defmodule BankAccount do
  # Función pública
  def create_account(initial_balance) when initial_balance >= 0 do
    %{
      id: generate_account_id(),
      balance: initial_balance,
      transactions: []
    }
  end
  
  def deposit(account, amount) when amount > 0 do
    new_balance = account.balance + amount
    transaction = create_transaction(:deposit, amount)
    
    %{account | 
      balance: new_balance,
      transactions: [transaction | account.transactions]
    }
  end
  
  def withdraw(account, amount) when amount > 0 do
    if can_withdraw?(account, amount) do
      new_balance = account.balance - amount
      transaction = create_transaction(:withdrawal, amount)
      
      {:ok, %{account | 
        balance: new_balance,
        transactions: [transaction | account.transactions]
      }}
    else
      {:error, "Insufficient funds"}
    end
  end
  
  def get_balance(account), do: account.balance
  
  # Funciones privadas
  defp generate_account_id do
    :crypto.strong_rand_bytes(8) |> Base.encode16()
  end
  
  defp can_withdraw?(account, amount) do
    account.balance >= amount
  end
  
  defp create_transaction(type, amount) do
    %{
      type: type,
      amount: amount,
      timestamp: DateTime.utc_now()
    }
  end
end

# Uso del módulo
account = BankAccount.create_account(1000)
account = BankAccount.deposit(account, 500)
{:ok, account} = BankAccount.withdraw(account, 200)
balance = BankAccount.get_balance(account)  # 1300

# ❌ Esto no funciona - funciones privadas no son accesibles
# BankAccount.generate_account_id()  # Error: undefined function
```

## Organización de funciones privadas:

```elixir
defmodule UserService do
  # ============== Funciones públicas ==============
  
  def register_user(params) do
    with {:ok, validated_params} <- validate_params(params),
         {:ok, user} <- create_user_record(validated_params),
         {:ok, _} <- send_welcome_email(user) do
      {:ok, user}
    end
  end
  
  def authenticate_user(email, password) do
    with {:ok, user} <- find_user_by_email(email),
         true <- verify_password(password, user.password_hash) do
      {:ok, user}
    else
      {:error, _} -> {:error, "Invalid credentials"}
      false -> {:error, "Invalid credentials"}
    end
  end
  
  # ============== Funciones privadas ==============
  
  defp validate_params(params) do
    # validación de parámetros
    if valid_email?(params["email"]) and valid_password?(params["password"]) do
      {:ok, params}
    else
      {:error, "Invalid parameters"}
    end
  end
  
  defp valid_email?(email) when is_binary(email) do
    String.contains?(email, "@") and String.length(email) > 5
  end
  
  defp valid_password?(password) when is_binary(password) do
    String.length(password) >= 8
  end
  
  defp create_user_record(params) do
    user = %{
      id: generate_user_id(),
      email: params["email"],
      password_hash: hash_password(params["password"]),
      created_at: DateTime.utc_now()
    }
    {:ok, user}
  end
  
  defp generate_user_id do
    System.unique_integer([:positive])
  end
  
  defp hash_password(password) do
    # Simulación de hash de password
    :crypto.hash(:sha256, password) |> Base.encode16()
  end
  
  defp find_user_by_email(email) do
    # Simulación de búsqueda en base de datos
    {:ok, %{email: email, password_hash: "hashed_password"}}
  end
  
  defp verify_password(password, hash) do
    hash_password(password) == hash
  end
  
  defp send_welcome_email(user) do
    # Simulación de envío de email
    {:ok, "Email sent to #{user.email}"}
  end
end
```


# Operador Pipe

El operador pipe (`|>`) permite encadenar llamadas a funciones de manera legible.

```elixir
# Sin pipe operator (anidado y difícil de leer)
result = String.trim(String.downcase(String.reverse("  HELLO WORLD  ")))

# Con pipe operator (legible de arriba a abajo)
result = "  HELLO WORLD  "
|> String.reverse()
|> String.downcase()
|> String.trim()
# "dlrow olleh"
```

## Ejemplos prácticos con pipe:

```elixir
defmodule DataProcessor do
  def process_users(users) do
    users
    |> Enum.filter(&(&1.active))
    |> Enum.map(&normalize_user/1)
    |> Enum.sort_by(&(&1.name))
    |> Enum.take(10)
  end
  
  def process_text(text) do
    text
    |> String.trim()
    |> String.downcase()
    |> String.split()
    |> Enum.map(&String.capitalize/1)
    |> Enum.join(" ")
  end
  
  def calculate_statistics(numbers) do
    numbers
    |> Enum.filter(&is_number/1)
    |> Enum.sort()
    |> then(&%{
      count: length(&1),
      min: List.first(&1),
      max: List.last(&1),
      sum: Enum.sum(&1),
      avg: Enum.sum(&1) / length(&1)
    })
  end
  
  defp normalize_user(user) do
    %{user | 
      name: String.trim(user.name),
      email: String.downcase(user.email)
    }
  end
end

# Uso con datos complejos
users_data = [
  %{name: " Juan ", email: "JUAN@EMAIL.COM", active: true},
  %{name: "Ana", email: "ana@email.com", active: false},
  %{name: " Luis ", email: "LUIS@EMAIL.COM", active: true}
]

processed_users = DataProcessor.process_users(users_data)
# [%{name: "Juan", email: "juan@email.com", active: true}, 
#  %{name: "Luis", email: "luis@email.com", active: true}]
```

## Uso avanzado del pipe operator:

```elixir
defmodule AdvancedPipe do
  def complex_transformation(data) do
    data
    |> Map.get(:items, [])
    |> Enum.filter(&valid_item?/1)
    |> Enum.group_by(&(&1.category))
    |> Enum.map(fn {category, items} ->
      {category, calculate_category_stats(items)}
    end)
    |> Enum.into(%{})
  end
  
  # Usando then/2 para operaciones que no siguen el patrón estándar
  def process_with_then(list) do
    list
    |> Enum.map(&(&1 * 2))
    |> then(&{:ok, &1})  # Envolver en tupla
    |> then(fn {:ok, data} -> 
      IO.puts("Processing #{length(data)} items")
      data
    end)
  end
  
  # Usando tap/2 para efectos secundarios sin cambiar el valor
  def process_with_tap(data) do
    data
    |> validate_data()
    |> tap(&IO.inspect(&1, label: "After validation"))
    |> transform_data()
    |> tap(&log_transformation_result/1)
    |> save_data()
  end
  
  defp valid_item?(item), do: not is_nil(item.value)
  defp calculate_category_stats(items), do: %{count: length(items)}
  defp validate_data(data), do: data
  defp transform_data(data), do: data
  defp log_transformation_result(_data), do: :ok
  defp save_data(data), do: {:ok, data}
end
```


# Módulos

Los módulos son la unidad básica de organización de código en Elixir.

```elixir
defmodule Calculator do
  @moduledoc """
  Un módulo para operaciones matemáticas básicas.
  
  Este módulo proporciona funciones para realizar cálculos
  matemáticos comunes como suma, resta, multiplicación y división.
  """
  
  @doc """
  Suma dos números.
  
  ## Ejemplos
  
      iex> Calculator.add(2, 3)
      5
      
      iex> Calculator.add(-1, 1)
      0
  """
  def add(a, b) when is_number(a) and is_number(b) do
    a + b
  end
  
  @doc """
  Resta dos números.
  """
  def subtract(a, b) when is_number(a) and is_number(b) do
    a - b
  end
  
  @doc false  # No aparece en la documentación generada
  def internal_helper do
    "This is internal"
  end
end
```

## Atributos de módulo:

```elixir
defmodule Configuration do
  @moduledoc "Módulo de configuración de la aplicación"
  
  # Atributos como constantes
  @default_timeout 5000
  @max_retries 3
  @supported_formats ["json", "xml", "csv"]
  
  # Atributos calculados en tiempo de compilación
  @compile_time DateTime.utc_now()
  @version Mix.Project.config()[:version] || "0.1.0"
  
  def get_timeout, do: @default_timeout
  def get_max_retries, do: @max_retries
  def supported_formats, do: @supported_formats
  def version, do: @version
  def compiled_at, do: @compile_time
  
  # Usar atributos en guards
  def valid_format?(format) when format in @supported_formats do
    true
  end
  def valid_format?(_), do: false
end
```

## Módulos anidados:

```elixir
defmodule MyApp do
  defmodule User do
    defstruct [:id, :name, :email, :created_at]
    
    def new(name, email) do
      %__MODULE__{
        id: generate_id(),
        name: name,
        email: email,
        created_at: DateTime.utc_now()
      }
    end
    
    defp generate_id do
      System.unique_integer([:positive])
    end
  end
  
  defmodule UserService do
    alias MyApp.User
    
    def create_user(name, email) do
      User.new(name, email)
    end
    
    def get_user_info(%User{} = user) do
      "User: #{user.name} (#{user.email})"
    end
  end
end

# Uso
user = MyApp.User.new("Juan", "juan@email.com")
info = MyApp.UserService.get_user_info(user)
```

## Importación y aliases:

```elixir
defmodule DataAnalyzer do
  # Alias para módulos largos
  alias MyApp.DataProcessor, as: Processor
  alias MyApp.Utils.{FileHelper, DateHelper, StringHelper}
  
  # Importar funciones específicas
  import Enum, only: [map: 2, filter: 2, reduce: 3]
  import String, only: [trim: 1, downcase: 1]
  
  # Usar módulos externos
  use GenServer  # Inyecta código del módulo GenServer
  
  def analyze_data(raw_data) do
    raw_data
    |> Processor.clean_data()
    |> map(&transform_item/1)       # Enum.map sin prefijo
    |> filter(&valid_item?/1)       # Enum.filter sin prefijo
    |> FileHelper.save_to_file("results.json")
  end
  
  defp transform_item(item) do
    %{item | name: trim(downcase(item.name))}  # String functions sin prefijo
  end
  
  defp valid_item?(item) do
    not is_nil(item.value)
  end
end
```