# Introducción a la Ingeniería Inversa (RE)

## ¿Qué es la Ingeniería Inversa?

La **Ingeniería Inversa (Reverse Engineering)** es el proceso de analizar un sistema, software o dispositivo para entender su funcionamiento interno, estructura y comportamiento sin tener acceso al código fuente original.

## Objetivos de la Ingeniería Inversa en Malware

- **Comprensión del comportamiento**: Entender qué hace el malware
- **Identificación de vulnerabilidades**: Encontrar puntos débiles explotados
- **Desarrollo de contramedidas**: Crear firmas y herramientas de detección
- **Análisis forense**: Investigar incidentes de seguridad
- **Educación**: Aprender sobre técnicas de ataque

## Tipos de Ingeniería Inversa

### Análisis Estático

- **Definición**: Examinar el código sin ejecutarlo
- **Ventajas**:
    - Seguro (no se ejecuta el malware)
    - Análisis completo del código
    - Identificación de todas las funcionalidades
- **Desventajas**:
    - Limitado por obfuscación
    - Requiere más tiempo
    - Puede ser complejo para principiantes

### Análisis Dinámico

- **Definición**: Ejecutar el malware en un entorno controlado
- **Ventajas**:
    - Observación del comportamiento real
    - Bypassa algunas técnicas de obfuscación
    - Más rápido para entender funcionalidades básicas
- **Desventajas**:
    - Riesgo de infección
    - Puede no activar todas las funcionalidades
    - Requiere entorno aislado

### Análisis Híbrido

- **Definición**: Combinación de análisis estático y dinámico
- **Ventajas**: Aprovecha los beneficios de ambos enfoques
- **Aplicación**: Más completo y efectivo

## Conceptos Fundamentales

### Arquitectura de Procesadores

- **x86**: Arquitectura de 32 bits
- **x64**: Arquitectura de 64 bits
- **Registros**: Almacenamiento temporal de datos
- **Stack**: Pila de ejecución
- **Heap**: Memoria dinámica

### Formato de Archivos Ejecutables

- **PE (Portable Executable)**: Formato de Windows
- **ELF (Executable and Linkable Format)**: Formato de Linux
- **Mach-O**: Formato de macOS

### Lenguaje Ensamblador

- **Instrucciones básicas**: MOV, ADD, SUB, JMP, CALL
- **Operandos**: Registros, memoria, inmediatos
- **Flujo de control**: Saltos condicionales e incondicionales


# Configuración del Laboratorio de RE

## Requisitos del Sistema

### Hardware Mínimo

- **RAM**: 8GB mínimo, 16GB recomendado
- **Almacenamiento**: 100GB libres
- **Procesador**: Intel i5 o AMD Ryzen 5 (soporte para virtualización)

### Software Base

- **Hipervisor**: VMware Workstation/VirtualBox
- **Sistema Host**: Windows 10/11 o Linux
- **Máquina Virtual**: Windows 10/11 aislada

## Herramientas Esenciales

### Desensambladores

```markdown
**IDA Pro**
- Descripción: Desensamblador profesional líder en la industria
- Características: Análisis avanzado, scripting, plugins
- Licencia: Comercial (versión gratuita limitada)
- Uso: Análisis estático profundo

**Ghidra**
- Descripción: Herramienta de ingeniería inversa de la NSA
- Características: Gratuita, código abierto, decompilador
- Licencia: Open Source
- Uso: Alternativa gratuita a IDA Pro

**Radare2**
- Descripción: Framework de ingeniería inversa
- Características: Línea de comandos, multiplataforma
- Licencia: Open Source
- Uso: Análisis avanzado, scripting
```

### Debuggers

```markdown
**x64dbg**
- Descripción: Debugger para Windows (32/64 bits)
- Características: Interfaz gráfica, plugins
- Licencia: Open Source
- Uso: Análisis dinámico, debugging

**OllyDbg**
- Descripción: Debugger clásico para Windows 32 bits
- Características: Interfaz simple, ampliamente usado
- Licencia: Freeware
- Uso: Análisis de malware x86

**WinDbg**
- Descripción: Debugger oficial de Microsoft
- Características: Potente, análisis de kernel
- Licencia: Gratuita
- Uso: Debugging avanzado, análisis de crashes
```

### Monitores de Sistema


```markdown
**Process Monitor (ProcMon)**
- Función: Monitoreo de filesystem, registry, procesos
- Desarrollador: Microsoft Sysinternals
- Uso: Análisis de comportamiento dinámico

**Process Explorer**
- Función: Explorador avanzado de procesos
- Desarrollador: Microsoft Sysinternals
- Uso: Análisis de procesos en tiempo real

**API Monitor**
- Función: Monitoreo de llamadas API
- Desarrollador: Rohitab
- Uso: Análisis de interacciones con el sistema
```

## Configuración del Entorno

### Configuración de VMware


```bash
# Configuración recomendada para VM de análisis
- RAM: 4GB mínimo
- Almacenamiento: 60GB
- Red: Host-only o NAT (aislada)
- Snapshots: Crear snapshot limpio
- Herramientas: Instalar VMware Tools
```

### Configuración de Windows VM

```powershell
# Desactivar Windows Defender
Set-MpPreference -DisableRealtimeMonitoring $true

# Desactivar Windows Update
sc config wuauserv start= disabled

# Configurar política de ejecución
Set-ExecutionPolicy Unrestricted

# Instalar .NET Framework
# Instalar Visual C++ Redistributables
```

### Configuración de Red

```markdown
**Modo Aislado**
- Configurar red Host-only
- Sin acceso a Internet
- Análisis seguro de malware

**Modo Controlado**
- Configurar INetSim para simular servicios
- Análisis de comunicación de red
- Captura de tráfico malicioso
```


# Demostración de Ingeniería Inversa de Malware

## Caso de Estudio: Análisis de Ransomware Básico

### Preparación del Análisis

```markdown
**Pasos Iniciales:**
1. Obtener muestra de malware (repositorio seguro)
2. Crear snapshot de VM limpia
3. Copiar muestra a VM aislada
4. Verificar hash del archivo
5. Iniciar herramientas de monitoreo
```

### Análisis Estático Inicial

```bash
# Información básica del archivo
file sample.exe
ls -la sample.exe

# Cálculo de hashes
md5sum sample.exe
sha1sum sample.exe
sha256sum sample.exe

# Strings del archivo
strings sample.exe | head -20
```

### Análisis con Herramientas Automatizadas

```markdown
**VirusTotal**
- Subir hash (no el archivo)
- Revisar detecciones
- Analizar comportamiento reportado

**Hybrid Analysis**
- Análisis automatizado
- Reporte de comportamiento
- Indicadores de compromiso
```

## Análisis Estático Profundo

### Análisis de PE Header

```python
# Usando pefile en Python
import pefile

pe = pefile.PE('sample.exe')

# Información básica
print(f"Entry Point: {hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}")
print(f"Image Base: {hex(pe.OPTIONAL_HEADER.ImageBase)}")
print(f"File Alignment: {pe.OPTIONAL_HEADER.FileAlignment}")

# Secciones
for section in pe.sections:
    print(f"Section: {section.Name.decode()}")
    print(f"Virtual Address: {hex(section.VirtualAddress)}")
    print(f"Size: {section.SizeOfRawData}")
```

### Análisis de Imports

```python
# Análisis de librerías importadas
if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print(f"DLL: {entry.dll.decode()}")
        for imp in entry.imports:
            if imp.name:
                print(f"  Function: {imp.name.decode()}")
```

### Análisis con IDA Pro

```assembly
; Punto de entrada principal
.text:00401000 push    ebp
.text:00401001 mov     ebp, esp
.text:00401003 sub     esp, 10h
.text:00401006 push    offset aHelloWorld ; "Hello World"
.text:0040100B call    printf
.text:00401010 add     esp, 4
.text:00401013 xor     eax, eax
.text:00401015 mov     esp, ebp
.text:00401017 pop     ebp
.text:00401018 retn
```

## Análisis Dinámico

### Monitoreo con Process Monitor

```markdown
**Configuración de Filtros:**
1. Process Name contains "sample"
2. Operation is WriteFile
3. Path contains "Documents"

**Análisis de Resultados:**
- Archivos creados/modificados
- Entradas de registro
- Accesos a red
```

### Debugging con x64dbg

```assembly
# Breakpoints estratégicos
bp CreateFileW
bp WriteFile
bp RegSetValueExW
bp InternetOpenW

# Análisis de parámetros
# Seguimiento de ejecución
# Modificación de valores
```

### Análisis de Red

```bash
# Captura con Wireshark
# Filtros importantes:
http
dns
tcp.port == 80
tcp.port == 443

# Análisis de tráfico
# Identificación de C&C
# Extracción de payloads
```

## Técnicas de Evasión y Contramedidas

### Detección de Análisis

```c
// Detección de debugger
if (IsDebuggerPresent()) {
    ExitProcess(0);
}

// Detección de VM
if (GetSystemMetrics(SM_CXSCREEN) < 800) {
    ExitProcess(0);
}

// Timing checks
DWORD start = GetTickCount();
Sleep(1000);
if (GetTickCount() - start < 950) {
    ExitProcess(0);
}
```

### Bypassing Anti-Analysis

```markdown
**Técnicas de Bypass:**
1. Parchear checks de debugger
2. Modificar valores de retorno
3. Usar debuggers avanzados
4. Emular entornos reales
```


# Herramientas y Técnicas Avanzadas

## Análisis de Malware Empaquetado

### Detección de Packing

```python
import pefile
import math

def calculate_entropy(data):
    """Calcular entropía de datos"""
    entropy = 0
    for i in range(256):
        p = float(data.count(chr(i))) / len(data)
        if p > 0:
            entropy += -p * math.log(p, 2)
    return entropy

# Análisis de entropía por sección
pe = pefile.PE('packed_sample.exe')
for section in pe.sections:
    entropy = calculate_entropy(section.get_data())
    print(f"Section {section.Name.decode()}: Entropy = {entropy:.2f}")
```

### Unpacking Manual

```assembly
; Técnica de unpacking
; 1. Encontrar OEP (Original Entry Point)
; 2. Establecer breakpoint en jump to OEP
; 3. Ejecutar hasta el breakpoint
; 4. Dumpear proceso desde memoria
```

## Análisis de Shellcode

### Extracción de Shellcode

```python
# Búsqueda de patrones de shellcode
shellcode_patterns = [
    b'\xfc\x48\x83\xe4\xf0\xe8',  # Windows x64
    b'\xfc\x48\x83\xe4\xf0\xe8',  # Meterpreter
    b'\x31\xc0\x50\x68\x2f\x2f\x73\x68'  # Linux execve
]

def find_shellcode(data):
    for pattern in shellcode_patterns:
        pos = data.find(pattern)
        if pos != -1:
            return pos
    return -1
```

### Análisis de Shellcode

```python
# Usando capstone para desensamblado
from capstone import *

def disassemble_shellcode(shellcode):
    md = Cs(CS_ARCH_X86, CS_MODE_64)
    for i in md.disasm(shellcode, 0x1000):
        print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
```

## Análisis de Comunicación C&C

### Interceptación de Tráfico

```python
# Usando mitmproxy para interceptar HTTPS
from mitmproxy import http

def response(flow: http.HTTPFlow) -> None:
    if "malicious-domain.com" in flow.request.pretty_host:
        print(f"Intercepted: {flow.request.url}")
        print(f"Data: {flow.request.content}")
```

### Análisis de Protocolos Personalizados

```python
# Análisis de protocolo binario
import struct

def parse_c2_protocol(data):
    # Estructura: [CMD][LEN][DATA]
    if len(data) < 8:
        return None
    
    cmd, length = struct.unpack('<HH', data[:4])
    payload = data[4:4+length]
    
    return {
        'command': cmd,
        'length': length,
        'payload': payload
    }
```


# Casos Prácticos

## Análisis de Trojan Bancario

### Características Típicas

```markdown
**Comportamiento Común:**
- Inyección en procesos de navegador
- Hooking de APIs de red
- Captura de formularios web
- Exfiltración de datos
- Comunicación con C&C
```

### Técnicas de Análisis

```c
// Detección de hooks
HMODULE hMod = GetModuleHandle(L"wininet.dll");
FARPROC pOriginal = GetProcAddress(hMod, "HttpSendRequestW");

// Verificar si la función está hookeada
if (*(BYTE*)pOriginal == 0xE9) {  // JMP instruction
    printf("HttpSendRequestW is hooked!\n");
}
```

## Análisis de Ransomware

### Flujo de Ejecución Típico

```markdown
**Fases del Ransomware:**
1. Reconocimiento del sistema
2. Generación/obtención de claves
3. Enumeración de archivos
4. Cifrado de archivos
5. Eliminación de backups
6. Despliegue de nota de rescate
```

### Puntos de Análisis Críticos

```python
# Monitoreo de operaciones de cifrado
import os
import time

def monitor_file_changes():
    """Monitorear cambios en archivos"""
    original_files = set(os.listdir('.'))
    time.sleep(5)
    current_files = set(os.listdir('.'))
    
    new_files = current_files - original_files
    for file in new_files:
        print(f"New file created: {file}")
```

## Análisis de Rootkit

### Detección de Rootkit

```c
// Detección de SSDT hooking
ULONG_PTR KeServiceDescriptorTable;
ULONG_PTR* ServiceTable;

// Verificar integridad de system calls
for (int i = 0; i < ServiceTableSize; i++) {
    if (!IsAddressInKernel(ServiceTable[i])) {
        printf("System call %d is hooked!\n", i);
    }
}
```

### Análisis de Kernel Mode

```c
// Usando WinDbg para análisis de kernel
// Comandos útiles:
// !process 0 0 - Listar procesos
// !drvobj \Driver\DriverName - Analizar driver
// !analyze -v - Análisis automático de crash
```


# Mejores Prácticas

## Seguridad del Laboratorio

### Aislamiento de Red

```markdown
**Configuración Segura:**
- Usar VMs completamente aisladas
- Configurar redes host-only
- Nunca conectar VM infectada a red corporativa
- Usar VPN dedicada para investigación
```

### Gestión de Muestras

```markdown
**Almacenamiento Seguro:**
- Cifrar muestras con contraseñas fuertes
- Usar repositorios dedicados
- Documentar origen y características
- Mantener hashes para verificación
```

## Metodología de Análisis

### Proceso Sistemático

```markdown
**Flujo de Trabajo:**
1. Preparación del entorno
2. Análisis inicial (hashes, strings)
3. Análisis estático (PE, imports)
4. Análisis dinámico (comportamiento)
5. Ingeniería inversa profunda
6. Documentación de hallazgos
```

### Documentación

```markdown
**Elementos a Documentar:**
- Información básica del malware
- Indicadores de compromiso (IoCs)
- Técnicas utilizadas
- Comportamiento observado
- Contramedidas recomendadas
```

## Consideraciones Legales

### Aspectos Legales

```markdown
**Consideraciones Importantes:**
- Obtener muestras de fuentes legítimas
- No distribuir malware
- Cumplir con regulaciones locales
- Tener autorización institucional
- Usar solo para investigación/educación
```

### Ética en la Investigación

```markdown
**Principios Éticos:**
- Divulgación responsable
- No causar daño
- Proteger información sensible
- Colaborar con la comunidad
- Mantener confidencialidad
```