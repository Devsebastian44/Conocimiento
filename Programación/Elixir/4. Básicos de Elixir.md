# Tipos de Datos

Elixir tiene varios tipos de datos fundamentales:

## Tipos básicos:

```elixir
# Integers
integer = 42
large_integer = 1_000_000
binary_integer = 0b1010      # 10 en binario
octal_integer = 0o777        # 511 en octal
hex_integer = 0xFF           # 255 en hexadecimal

# Floats
float = 3.14
scientific = 1.0e-10

# Atoms
atom = :hello
atom_with_spaces = :"hello world"
boolean_true = true          # true es un atom
boolean_false = false        # false es un atom
nil_value = nil              # nil es un atom

# Strings (binarios UTF-8)
string = "Hello, world!"
multiline = """
This is a
multiline string
"""

# Binary
binary = <<1, 2, 3>>
string_binary = "hello"      # Las strings son binarios
```

## Verificación de tipos:

```elixir
# Funciones para verificar tipos
is_integer(42)           # true
is_float(3.14)           # true
is_atom(:hello)          # true
is_boolean(true)         # true
is_binary("hello")       # true
is_bitstring(<<1, 2>>)   # true
```


# Tuplas

Las tuplas son estructuras de datos de tamaño fijo que agrupan elementos.

```elixir
# Crear tuplas
empty_tuple = {}
coordinates = {10, 20}
person = {"Juan", 30, "Ingeniero"}
result = {:ok, "success"}
error = {:error, "file not found"}

# Acceder a elementos (índice basado en 0)
elem(coordinates, 0)     # 10
elem(coordinates, 1)     # 20

# Modificar tuplas (crea una nueva)
put_elem(coordinates, 0, 15)  # {15, 20}

# Tamaño de tupla
tuple_size(person)       # 3

# Pattern matching con tuplas
{x, y} = coordinates     # x = 10, y = 20
{:ok, message} = {:ok, "success"}  # message = "success"
```

## Usos comunes de tuplas:

```elixir
# Retorno de funciones con status
def divide(a, b) do
  if b == 0 do
    {:error, "Division by zero"}
  else
    {:ok, a / b}
  end
end

# Coordenadas
point = {10, 20, 30}

# Configuración
config = {:database, "localhost", 5432, "mydb"}
```


# Listas

Las listas son colecciones ordenadas de elementos de longitud variable.

```elixir
# Crear listas
empty_list = []
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", :atom, true]

# Operaciones básicas
length(numbers)          # 5
hd(numbers)             # 1 (head)
tl(numbers)             # [2, 3, 4, 5] (tail)

# Agregar elementos
new_list = [0 | numbers]        # [0, 1, 2, 3, 4, 5]
appended = numbers ++ [6, 7]    # [1, 2, 3, 4, 5, 6, 7]

# Verificar si está vacía
numbers == []           # false
[] == []               # true

# Pattern matching con listas
[first | rest] = [1, 2, 3, 4]   # first = 1, rest = [2, 3, 4]
[a, b | tail] = [1, 2, 3, 4, 5] # a = 1, b = 2, tail = [3, 4, 5]
```

## Operaciones con listas:

```elixir
# Concatenación
[1, 2] ++ [3, 4]        # [1, 2, 3, 4]

# Sustracción
[1, 2, 3, 4] -- [2, 4]  # [1, 3]

# Membership
2 in [1, 2, 3]          # true
5 in [1, 2, 3]          # false

# Enumeración
Enum.map([1, 2, 3], &(&1 * 2))     # [2, 4, 6]
Enum.filter([1, 2, 3, 4], &(&1 > 2)) # [3, 4]
```


# Maps

Los maps son estructuras de datos clave-valor.

```elixir
# Crear maps
empty_map = %{}
person = %{name: "Juan", age: 30, city: "Madrid"}
string_keys = %{"name" => "Ana", "age" => 25}

# Acceder a valores
person[:name]           # "Juan"
person.name            # "Juan" (solo con atoms como keys)
person["name"]         # nil (porque la key es atom, no string)

# Verificar existencia de keys
Map.has_key?(person, :name)     # true
Map.has_key?(person, :salary)   # false

# Obtener keys y valores
Map.keys(person)        # [:age, :city, :name]
Map.values(person)      # [30, "Madrid", "Juan"]

# Tamaño del map
map_size(person)        # 3
```

## Actualizar maps:

```elixir
# Actualizar valores existentes
updated_person = %{person | age: 31}
# %{name: "Juan", age: 31, city: "Madrid"}

# Agregar nuevas keys
with_salary = Map.put(person, :salary, 50000)
# %{name: "Juan", age: 30, city: "Madrid", salary: 50000}

# Múltiples actualizaciones
Map.merge(person, %{age: 31, job: "Developer"})
# %{name: "Juan", age: 31, city: "Madrid", job: "Developer"}

# Eliminar keys
Map.delete(person, :city)
# %{name: "Juan", age: 30}
```


## Accediendo a un Map

```elixir
person = %{name: "Juan", age: 30, address: %{city: "Madrid", country: "Spain"}}

# Acceso básico
person[:name]                    # "Juan"
person.name                      # "Juan"

# Acceso con valor por defecto
Map.get(person, :salary, 0)      # 0 (valor por defecto)

# Acceso a maps anidados
person[:address][:city]          # "Madrid"
get_in(person, [:address, :city]) # "Madrid"

# Acceso seguro (retorna nil si no existe)
person[:nonexistent]             # nil
get_in(person, [:address, :postal_code]) # nil

# Pattern matching con maps
%{name: person_name} = person    # person_name = "Juan"
%{name: name, age: age} = person # name = "Juan", age = 30
```


# Date

Elixir proporciona tipos para manejar fechas.

```elixir
# Crear fechas
today = Date.utc_today()
specific_date = ~D[2023-12-25]   # Usando sigil
manual_date = Date.new!(2023, 12, 25)

# Información de fecha
Date.day_of_week(today)          # 1-7 (1 = Monday)
Date.day_of_year(today)          # 1-366
Date.days_in_month(today)        # 28-31

# Operaciones con fechas
Date.add(today, 7)               # Agregar 7 días
Date.diff(~D[2023-12-31], ~D[2023-01-01])  # Diferencia en días

# Comparaciones
Date.compare(~D[2023-01-01], ~D[2023-12-31])  # :lt, :eq, :gt

# Conversiones
Date.to_string(today)            # "2023-07-18"
Date.to_erl(today)              # {2023, 7, 18}
```


# Time

Manejo de tiempo sin zona horaria.

```elixir
# Crear tiempo
now = Time.utc_now()
specific_time = ~T[14:30:00]     # Usando sigil
manual_time = Time.new!(14, 30, 0)

# Con microsegundos
precise_time = Time.new!(14, 30, 0, 123456)

# Operaciones con tiempo
Time.add(now, 3600)              # Agregar 1 hora (3600 segundos)
Time.diff(~T[15:00:00], ~T[14:30:00])  # Diferencia en segundos

# Comparaciones
Time.compare(~T[14:30:00], ~T[15:00:00])  # :lt

# Conversiones
Time.to_string(now)              # "14:30:00.123456"
Time.to_erl(now)                # {14, 30, 0}
```


# Nuestra Espectacular IEx

IEx (Interactive Elixir) es el shell interactivo de Elixir.

#### Comandos básicos de IEx:

```elixir
# Iniciar IEx
iex

# Ayuda
h                        # Ayuda general
h Enum                   # Ayuda sobre módulo Enum
h Enum.map               # Ayuda sobre función específica

# Información
i "hello"                # Información sobre valor
i 42

# Historial
v                        # Valor de la última expresión
v(1)                     # Valor de la expresión número 1
v(-2)                    # Valor de dos expresiones atrás

# Recompilar
r ModuleName             # Recompilar módulo
recompile                # Recompilar todo el proyecto

# Salir
exit                     # Salir de IEx
```

## Configuración de IEx:

```elixir
# En ~/.iex.exs
# Configuraciones personalizadas
IO.puts("¡Bienvenido a IEx!")

# Importar módulos comunes
import_if_available(Ecto.Query)
import_if_available(Ecto.Changeset)

# Aliases útiles
alias MyApp.{User, Post, Comment}
```

## Funciones útiles en IEx:

```elixir
# Depuración
IO.inspect(data, label: "Debug")

# Benchmark simple
:timer.tc(fn -> expensive_operation() end)

# Información del sistema
:observer.start()        # Abrir observer (GUI)
```


# Conventions

## Convenciones de nomenclatura:

```elixir
# Variables y funciones: snake_case
user_name = "Juan"
def calculate_total(items), do: Enum.sum(items)

# Módulos: PascalCase
defmodule UserController do
  def index do
    # código
  end
end

# Atoms: snake_case con :
:user_created
:error_not_found

# Constantes: SCREAMING_SNAKE_CASE
@max_retries 3
@default_timeout 5000
```

## Convenciones de estructura:

```elixir
# Orden en módulos
defmodule MyModule do
  # 1. Atributos de módulo
  @moduledoc "Documentación del módulo"
  @default_value 42
  
  # 2. Alias, import, use
  alias MyApp.User
  import MyApp.Utils
  use MyApp.Base
  
  # 3. Funciones públicas
  def public_function do
    # código
  end
  
  # 4. Funciones privadas
  defp private_function do
    # código
  end
end
```


# Operadores

## Operadores aritméticos:

```elixir
# Básicos
1 + 2                    # 3
5 - 3                    # 2
3 * 4                    # 12
10 / 3                   # 3.3333333333333335
div(10, 3)               # 3 (división entera)
rem(10, 3)               # 1 (residuo)

# Exponenciación
:math.pow(2, 3)          # 8.0
```

## Operadores de comparación:

```elixir
# Igualdad
1 == 1                   # true
1 == 1.0                 # true (compara valores)
1 === 1.0                # false (compara tipos también)

# Desigualdad
1 != 2                   # true
1 !== 1.0                # true

# Comparación
1 < 2                    # true
2 > 1                    # true
1 <= 1                   # true
2 >= 1                   # true
```

## Operadores lógicos:

```elixir
# Booleanos
true and false           # false
true or false            # true
not true                 # false

# Corto-circuito (más usados)
true && false            # false
false || true            # true
!true                    # false

# Operadores de pipe
"hello" |> String.upcase() |> String.reverse()  # "OLLEH"
```

## Operadores de concatenación:

```elixir
# Listas
[1, 2] ++ [3, 4]         # [1, 2, 3, 4]
[1, 2, 3] -- [2]         # [1, 3]

# Strings
"Hello" <> " " <> "World"  # "Hello World"

# Binarios
<<1, 2>> <> <<3, 4>>     # <<1, 2, 3, 4>>
```


# Scope

En Elixir, el scope (ámbito) determina dónde están disponibles las variables.

## Scope en funciones:

```elixir
defmodule ScopeExample do
  @module_attr "I'm a module attribute"
  
  def function_scope do
    x = 1                # x solo existe en esta función
    y = 2
    x + y
  end
  
  def another_function do
    # x y y no están disponibles aquí
    z = 3
    z * 2
  end
end
```

## Scope en case, cond, if:

```elixir
x = 1

case x do
  1 ->
    y = "uno"           # y solo existe en esta rama
    y
  _ ->
    z = "otro"          # z solo existe en esta rama
    z
end

# y y z no están disponibles aquí
```

## Scope en comprehensions:

```elixir
x = 1

# Las variables en comprehensions no filtran al scope exterior
result = for i <- 1..3 do
  temp = i * 2          # temp no existe fuera del comprehension
  temp
end

# temp no está disponible aquí
```


# Sentencia With

La sentencia `with` permite encadenar operaciones que pueden fallar de manera elegante.

```elixir
# Ejemplo básico
with {:ok, file} <- File.read("config.txt"),
     {:ok, data} <- Jason.decode(file),
     %{"database" => db_config} <- data do
  connect_to_database(db_config)
else
  {:error, reason} -> {:error, "Failed to read config: #{reason}"}
  :error -> {:error, "Invalid JSON"}
  _ -> {:error, "Missing database config"}
end
```

## Ejemplo más complejo:

```elixir
defmodule UserRegistration do
  def register_user(params) do
    with {:ok, email} <- validate_email(params["email"]),
         {:ok, password} <- validate_password(params["password"]),
         {:ok, user} <- create_user(email, password),
         {:ok, _} <- send_welcome_email(user) do
      {:ok, user}
    else
      {:error, :invalid_email} -> {:error, "Email is invalid"}
      {:error, :weak_password} -> {:error, "Password is too weak"}
      {:error, :user_exists} -> {:error, "User already exists"}
      {:error, :email_failed} -> {:error, "Failed to send welcome email"}
    end
  end
  
  defp validate_email(email) when is_binary(email) do
    if String.contains?(email, "@") do
      {:ok, email}
    else
      {:error, :invalid_email}
    end
  end
  
  defp validate_password(password) when is_binary(password) do
    if String.length(password) >= 8 do
      {:ok, password}
    else
      {:error, :weak_password}
    end
  end
  
  defp create_user(email, password) do
    # Simulación de creación de usuario
    {:ok, %{id: 1, email: email, password: password}}
  end
  
  defp send_welcome_email(user) do
    # Simulación de envío de email
    {:ok, "Email sent to #{user.email}"}
  end
end
```

## With y Pattern Matching

La sentencia `with` se combina perfectamente con pattern matching.

```elixir
# Pattern matching en with
with [name, age_str] <- String.split(input, ","),
     {age, ""} <- Integer.parse(age_str),
     true <- age > 0 do
  {:ok, %{name: name, age: age}}
else
  _ -> {:error, "Invalid input format"}
end

# Con múltiples patrones
with {:ok, %{"users" => users}} <- fetch_data(),
     [%{"id" => id, "name" => name} | _] <- users,
     {:ok, details} <- fetch_user_details(id) do
  {:ok, %{name: name, details: details}}
else
  {:error, reason} -> {:error, reason}
  [] -> {:error, "No users found"}
  _ -> {:error, "Invalid data format"}
end
```

## Usando guardas en with:

```elixir
with {:ok, number} <- parse_number(input),
     true <- number > 0 and number < 100 do
  {:ok, number}
else
  {:error, reason} -> {:error, reason}
  false -> {:error, "Number must be between 1 and 99"}
end
```