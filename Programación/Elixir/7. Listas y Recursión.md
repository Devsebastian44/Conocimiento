# Head y Tail

En Elixir, las listas se componen de un **head** (cabeza) y un **tail** (cola).

```elixir
# Estructura básica de lista
list = [1, 2, 3, 4, 5]

# Head es el primer elemento
head = hd(list)          # 1

# Tail es el resto de la lista
tail = tl(list)          # [2, 3, 4, 5]

# Con listas vacías
empty_list = []
# hd([])  # Esto genera error
# tl([])  # Esto genera error

# Verificar si una lista está vacía
list == []               # false
empty_list == []         # true

# Lista con un solo elemento
single_item = [42]
hd(single_item)          # 42
tl(single_item)          # []
```

## Pattern matching con head y tail:

```elixir
# Extraer head y tail con pattern matching
[h | t] = [1, 2, 3, 4, 5]
# h = 1, t = [2, 3, 4, 5]

# Extraer múltiples elementos
[first, second | rest] = [1, 2, 3, 4, 5]
# first = 1, second = 2, rest = [3, 4, 5]

# Ignorar elementos con _
[first | _rest] = [1, 2, 3, 4, 5]
# first = 1, _rest es ignorado

# Pattern matching en funciones
defmodule ListExamples do
  def first_element([head | _tail]), do: head
  def first_element([]), do: nil
  
  def second_element([_first, second | _rest]), do: second
  def second_element(_), do: nil
  
  def last_two([a, b]), do: [a, b]
  def last_two([_head | tail]), do: last_two(tail)
  def last_two(_), do: []
end

ListExamples.first_element([1, 2, 3])    # 1
ListExamples.second_element([1, 2, 3])   # 2
ListExamples.last_two([1, 2, 3, 4, 5])   # [4, 5]
```


# Head y Tail para Procesar Listas

La recursión con head y tail es fundamental para procesar listas en Elixir.

```elixir
defmodule ListProcessor do
  # Contar elementos de una lista
  def count([]), do: 0
  def count([_head | tail]), do: 1 + count(tail)
  
  # Sumar todos los elementos
  def sum([]), do: 0
  def sum([head | tail]), do: head + sum(tail)
  
  # Encontrar el elemento máximo
  def max([]), do: nil
  def max([single]), do: single
  def max([head | tail]) do
    tail_max = max(tail)
    if head > tail_max, do: head, else: tail_max
  end
  
  # Verificar si un elemento existe
  def member?([], _element), do: false
  def member?([element | _tail], element), do: true
  def member?([_head | tail], element), do: member?(tail, element)
  
  # Obtener elemento en posición específica
  def at([], _index), do: nil
  def at([head | _tail], 0), do: head
  def at([_head | tail], index) when index > 0 do
    at(tail, index - 1)
  end
end

# Ejemplos de uso
ListProcessor.count([1, 2, 3, 4])        # 4
ListProcessor.sum([1, 2, 3, 4])          # 10
ListProcessor.max([3, 1, 4, 1, 5])       # 5
ListProcessor.member?([1, 2, 3], 2)      # true
ListProcessor.at([1, 2, 3, 4], 2)        # 3
```

## Procesamiento con acumuladores:

```elixir
defmodule ListAccumulator do
  # Contar con acumulador (tail call optimization)
  def count(list), do: count(list, 0)
  defp count([], acc), do: acc
  defp count([_head | tail], acc), do: count(tail, acc + 1)
  
  # Sumar con acumulador
  def sum(list), do: sum(list, 0)
  defp sum([], acc), do: acc
  defp sum([head | tail], acc), do: sum(tail, acc + head)
  
  # Reversar lista con acumulador
  def reverse(list), do: reverse(list, [])
  defp reverse([], acc), do: acc
  defp reverse([head | tail], acc), do: reverse(tail, [head | acc])
  
  # Filtrar elementos con acumulador
  def filter(list, fun), do: filter(list, fun, [])
  defp filter([], _fun, acc), do: reverse(acc)
  defp filter([head | tail], fun, acc) do
    if fun.(head) do
      filter(tail, fun, [head | acc])
    else
      filter(tail, fun, acc)
    end
  end
end

# Ejemplos
ListAccumulator.count([1, 2, 3, 4, 5])           # 5
ListAccumulator.sum([1, 2, 3, 4, 5])             # 15
ListAccumulator.reverse([1, 2, 3, 4, 5])         # [5, 4, 3, 2, 1]
ListAccumulator.filter([1, 2, 3, 4, 5], &(&1 > 3))  # [4, 5]
```


# Head y Tail para Construir una Lista

Usar head y tail para construir nuevas listas es una técnica común.

```elixir
defmodule ListBuilder do
  # Duplicar cada elemento
  def double([]), do: []
  def double([head | tail]), do: [head * 2 | double(tail)]
  
  # Agregar elemento al final (ineficiente)
  def append([], element), do: [element]
  def append([head | tail], element), do: [head | append(tail, element)]
  
  # Concatenar dos listas
  def concat([], list2), do: list2
  def concat([head | tail], list2), do: [head | concat(tail, list2)]
  
  # Tomar los primeros n elementos
  def take([], _n), do: []
  def take(_list, 0), do: []
  def take([head | tail], n) when n > 0 do
    [head | take(tail, n - 1)]
  end
  
  # Eliminar los primeros n elementos
  def drop(list, 0), do: list
  def drop([], _n), do: []
  def drop([_head | tail], n) when n > 0 do
    drop(tail, n - 1)
  end
end

# Ejemplos
ListBuilder.double([1, 2, 3, 4])           # [2, 4, 6, 8]
ListBuilder.append([1, 2, 3], 4)           # [1, 2, 3, 4]
ListBuilder.concat([1, 2], [3, 4])         # [1, 2, 3, 4]
ListBuilder.take([1, 2, 3, 4, 5], 3)       # [1, 2, 3]
ListBuilder.drop([1, 2, 3, 4, 5], 2)       # [3, 4, 5]
```

## Construcción eficiente de listas:

```elixir
defmodule EfficientListBuilder do
  # Construir lista hacia adelante (más eficiente)
  def build_range(from, to) when from > to, do: []
  def build_range(from, to), do: [from | build_range(from + 1, to)]
  
  # Construir lista con acumulador (tail recursive)
  def build_range_acc(from, to), do: build_range_acc(from, to, [])
  defp build_range_acc(from, to, acc) when from > to, do: Enum.reverse(acc)
  defp build_range_acc(from, to, acc) do
    build_range_acc(from + 1, to, [from | acc])
  end
  
  # Intercalar dos listas
  def interleave([], list2), do: list2
  def interleave(list1, []), do: list1
  def interleave([h1 | t1], [h2 | t2]) do
    [h1, h2 | interleave(t1, t2)]
  end
  
  # Particionar lista en pares
  def partition_pairs([]), do: []
  def partition_pairs([single]), do: [[single]]
  def partition_pairs([first, second | rest]) do
    [[first, second] | partition_pairs(rest)]
  end
end

# Ejemplos
EfficientListBuilder.build_range(1, 5)        # [1, 2, 3, 4, 5]
EfficientListBuilder.build_range_acc(1, 5)    # [1, 2, 3, 4, 5]
EfficientListBuilder.interleave([1, 3, 5], [2, 4, 6])  # [1, 2, 3, 4, 5, 6]
EfficientListBuilder.partition_pairs([1, 2, 3, 4, 5])  # [[1, 2], [3, 4], [5]]
```


# Creando una Función Map

Implementar nuestra propia versión de la función `map`.

```elixir
defmodule CustomMap do
  # Versión básica recursiva
  def map([], _fun), do: []
  def map([head | tail], fun) do
    [fun.(head) | map(tail, fun)]
  end
  
  # Versión con acumulador (tail recursive)
  def map_acc(list, fun), do: map_acc(list, fun, [])
  defp map_acc([], _fun, acc), do: Enum.reverse(acc)
  defp map_acc([head | tail], fun, acc) do
    map_acc(tail, fun, [fun.(head) | acc])
  end
  
  # Versión que maneja errores
  def safe_map([], _fun), do: {:ok, []}
  def safe_map([head | tail], fun) do
    case apply_safe(fun, head) do
      {:ok, result} ->
        case safe_map(tail, fun) do
          {:ok, rest} -> {:ok, [result | rest]}
          error -> error
        end
      error -> error
    end
  end
  
  # Map con índice
  def map_with_index(list, fun), do: map_with_index(list, fun, 0, [])
  defp map_with_index([], _fun, _index, acc), do: Enum.reverse(acc)
  defp map_with_index([head | tail], fun, index, acc) do
    result = fun.(head, index)
    map_with_index(tail, fun, index + 1, [result | acc])
  end
  
  defp apply_safe(fun, value) do
    try do
      {:ok, fun.(value)}
    rescue
      e -> {:error, e}
    end
  end
end

# Ejemplos de uso
CustomMap.map([1, 2, 3, 4], &(&1 * 2))
# [2, 4, 6, 8]

CustomMap.map_acc([1, 2, 3, 4], &(&1 * &1))
# [1, 4, 9, 16]

CustomMap.safe_map([1, 2, 3], fn x -> 
  if x == 2, do: raise("Error"), else: x * 2 
end)
# {:error, %RuntimeError{message: "Error"}}

CustomMap.map_with_index(["a", "b", "c"], fn item, index -> 
  "#{index}: #{item}" 
end)
# ["0: a", "1: b", "2: c"]
```


# Reducir una Lista a un Único Valor

Implementar funciones de reducción (fold/reduce).

```elixir
defmodule CustomReduce do
  # Reduce básico (fold left)
  def reduce([], acc, _fun), do: acc
  def reduce([head | tail], acc, fun) do
    reduce(tail, fun.(head, acc), fun)
  end
  
  # Reduce right (menos eficiente pero a veces necesario)
  def reduce_right([], acc, _fun), do: acc
  def reduce_right([head | tail], acc, fun) do
    fun.(head, reduce_right(tail, acc, fun))
  end
  
  # Reduce con valor inicial desde la lista
  def reduce([]), do: {:error, "empty list"}
  def reduce([single]), do: single
  def reduce([head | tail]) do
    reduce(tail, head, fn x, acc -> x + acc end)
  end
  
  # Scan - reduce que mantiene estados intermedios
  def scan([], _acc, _fun), do: []
  def scan([head | tail], acc, fun) do
    new_acc = fun.(head, acc)
    [new_acc | scan(tail, new_acc, fun)]
  end
  
  # Reduce con early termination
  def reduce_while([], acc, _fun), do: acc
  def reduce_while([head | tail], acc, fun) do
    case fun.(head, acc) do
      {:cont, new_acc} -> reduce_while(tail, new_acc, fun)
      {:halt, final_acc} -> final_acc
    end
  end
end

# Ejemplos de uso
CustomReduce.reduce([1, 2, 3, 4], 0, &(&1 + &2))
# 10

CustomReduce.reduce_right([1, 2, 3, 4], [], &[&1 | &2])
# [1, 2, 3, 4]

CustomReduce.scan([1, 2, 3, 4], 0, &(&1 + &2))
# [1, 3, 6, 10]

CustomReduce.reduce_while([1, 2, 3, 4, 5], 0, fn
  x, acc when acc + x < 6 -> {:cont, acc + x}
  _, acc -> {:halt, acc}
end)
# 6
```


# Patrones de Listas más Complejos

Patrones avanzados de pattern matching con listas.

```elixir
defmodule AdvancedListPatterns do
  # Trabajar con listas de tuplas
  def extract_names([]), do: []
  def extract_names([{name, _age} | rest]) do
    [name | extract_names(rest)]
  end
  
  # Pattern matching con guards
  def filter_adults([]), do: []
  def filter_adults([{name, age} | rest]) when age >= 18 do
    [name | filter_adults(rest)]
  end
  def filter_adults([_minor | rest]) do
    filter_adults(rest)
  end
  
  # Patterns con múltiples elementos
  def process_pairs([]), do: []
  def process_pairs([a, b | rest]) do
    [{a, b} | process_pairs(rest)]
  end
  def process_pairs([single]) do
    [{single, nil}]
  end
  
  # Pattern matching con valores específicos
  def count_specific([], _target), do: 0
  def count_specific([target | tail], target) do
    1 + count_specific(tail, target)
  end
  def count_specific([_other | tail], target) do
    count_specific(tail, target)
  end
  
  # Pattern matching con listas anidadas
  def flatten([]), do: []
  def flatten([head | tail]) when is_list(head) do
    flatten(head) ++ flatten(tail)
  end
  def flatten([head | tail]) do
    [head | flatten(tail)]
  end
  
  # Separar elementos pares e impares
  def separate_even_odd(list), do: separate_even_odd(list, [], [])
  defp separate_even_odd([], evens, odds), do: {Enum.reverse(evens), Enum.reverse(odds)}
  defp separate_even_odd([head | tail], evens, odds) when rem(head, 2) == 0 do
    separate_even_odd(tail, [head | evens], odds)
  end
  defp separate_even_odd([head | tail], evens, odds) do
    separate_even_odd(tail, evens, [head | odds])
  end
end

# Ejemplos
people = [{"Juan", 25}, {"Ana", 17}, {"Luis", 30}, {"María", 16}]
AdvancedListPatterns.extract_names(people)
# ["Juan", "Ana", "Luis", "María"]

AdvancedListPatterns.filter_adults(people)
# ["Juan", "Luis"]

AdvancedListPatterns.process_pairs([1, 2, 3, 4, 5])
# [{1, 2}, {3, 4}, {5, nil}]

AdvancedListPatterns.separate_even_odd([1, 2, 3, 4, 5, 6])
# {[2, 4, 6], [1, 3, 5]}
```


# Listas de Listas

Trabajar con estructuras de datos más complejas.

```elixir
defmodule NestedLists do
  # Aplanar una lista anidada un nivel
  def flatten_one_level([]), do: []
  def flatten_one_level([head | tail]) when is_list(head) do
    head ++ flatten_one_level(tail)
  end
  def flatten_one_level([head | tail]) do
    [head | flatten_one_level(tail)]
  end
  
  # Transponer matriz (convertir filas en columnas)
  def transpose([[] | _]), do: []
  def transpose(matrix) do
    [Enum.map(matrix, &hd/1) | transpose(Enum.map(matrix, &tl/1))]
  end
  
  # Encontrar elemento en matriz
  def find_in_matrix([], _target), do: nil
  def find_in_matrix([row | rest], target) do
    case find_in_row(row, target, 0) do
      nil -> find_in_matrix(rest, target)
      column -> {length(rest), column}
    end
  end
  
  defp find_in_row([], _target, _index), do: nil
  defp find_in_row([target | _], target, index), do: index
  defp find_in_row([_ | rest], target, index) do
    find_in_row(rest, target, index + 1)
  end
  
  # Sumar matrices
  def add_matrices([], []), do: []
  def add_matrices([row1 | rest1], [row2 | rest2]) do
    [add_rows(row1, row2) | add_matrices(rest1, rest2)]
  end
  
  defp add_rows([], []), do: []
  defp add_rows([a | rest1], [b | rest2]) do
    [a + b | add_rows(rest1, rest2)]
  end
  
  # Filtrar filas que cumplen condición
  def filter_rows([], _condition), do: []
  def filter_rows([row | rest], condition) do
    if condition.(row) do
      [row | filter_rows(rest, condition)]
    else
      filter_rows(rest, condition)
    end
  end
end

# Ejemplos
nested = [[1, 2], [3, 4], [5]]
NestedLists.flatten_one_level(nested)
# [1, 2, 3, 4, 5]

matrix = [[1, 2, 3], [4, 5, 6]]
NestedLists.transpose(matrix)
# [[1, 4], [2, 5], [3, 6]]

NestedLists.find_in_matrix([[1, 2], [3, 4]], 3)
# {1, 0}

matrix1 = [[1, 2], [3, 4]]
matrix2 = [[5, 6], [7, 8]]
NestedLists.add_matrices(matrix1, matrix2)
# [[6, 8], [10, 12]]
```


# Módulo de Lista de Acción

Un módulo completo que demuestra operaciones avanzadas con listas.

```elixir
defmodule ActionList do
  @moduledoc """
  Módulo que implementa operaciones avanzadas con listas usando recursión.
  """
  
  # ============== Operaciones básicas ==============
  
  def length([]), do: 0
  def length([_head | tail]), do: 1 + length(tail)
  
  def reverse(list), do: reverse(list, [])
  defp reverse([], acc), do: acc
  defp reverse([head | tail], acc), do: reverse(tail, [head | acc])
  
  def concat([], list2), do: list2
  def concat([head | tail], list2), do: [head | concat(tail, list2)]
  
  # ============== Transformaciones ==============
  
  def map([], _fun), do: []
  def map([head | tail], fun), do: [fun.(head) | map(tail, fun)]
  
  def filter([], _predicate), do: []
  def filter([head | tail], predicate) do
    if predicate.(head) do
      [head | filter(tail, predicate)]
    else
      filter(tail, predicate)
    end
  end
  
  def reject(list, predicate), do: filter(list, &(not predicate.(&1)))
  
  # ============== Agregaciones ==============
  
  def reduce([], acc, _fun), do: acc
  def reduce([head | tail], acc, fun) do
    reduce(tail, fun.(head, acc), fun)
  end
  
  def sum(list), do: reduce(list, 0, &(&1 + &2))
  def product(list), do: reduce(list, 1, &(&1 * &2))
  
  def min([]), do: nil
  def min([head | tail]), do: min(tail, head)
  defp min([], current_min), do: current_min
  defp min([head | tail], current_min) when head < current_min do
    min(tail, head)
  end
  defp min([_head | tail], current_min), do: min(tail, current_min)
  
  def max([]), do: nil
  def max([head | tail]), do: max(tail, head)
  defp max([], current_max), do: current_max
  defp max([head | tail], current_max) when head > current_max do
    max(tail, head)
  end
  defp max([_head | tail], current_max), do: max(tail, current_max)
  
  # ============== Búsquedas ==============
  
  def member?(
```